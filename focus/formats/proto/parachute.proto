syntax = "proto3";

package parachute;

message Target {
    string name = 1;
    Coordinate address = 2;
}

message Coordinate {
    // Name of the repository. e.g. '@external'. Empty for the current repo.
    string repository = 1;
    // Leading path components, NOT including the target name. e.g. ['tools', 'workspace', 'bazel-deps']
    repeated string component = 2;
}

message Repo {
    message Identifier {
        // This is to represent a UUID
        bytes id = 1;
    }

    Identifier identifier = 1;
    string name = 2;
}

message ContentDigest {
    enum Algorithm {
        SHA1 = 0;
        SHA256 = 1;
    }

    Algorithm algorithm = 1;
    bytes value = 2;
}

message QueryReposAction {
    message Request {
        // If `name_filter` is specified, only those repos whose name is an exact match will be returned. Otherwise, all repos are returned.
        string name_filter = 1;
    }

    message Response {
        repeated Repo repos = 1;
    }
}

message Sandbox {
    message Identifier {
        bytes id = 1;
    }

    message FileModification {
        uint64 creation_time = 1;
        uint64 access_time = 2;
        uint64 mode = 3;
        string path = 4;
        bytes contents = 5;
    }

    Identifier based_on_sandbox = 1; // Identifier of the sandbox, if any, that this sandbox should be based on.
    ContentDigest merge_base = 2;
    repeated FileModification modifications = 3;
}


message CreateSandbox {
    message Request {
        Repo.Identifier repo_identifier = 1;
    }

    message Response {
        Sandbox.Identifier identifier = 1; // Identifier for the sandbox
    }
}

message QueryTargetsAction {
    message Request {
    }

    message Response {
    }
}

message IsolateWorkspaceAction {
    message Request {
        Repo.Identifier repo_identifier = 1;
        Sandbox.Identifier sandbox_identifier = 2;
    }
    
    message Response {
    }
}

// N.B. This effectively emulates a stateful protocol.
//
// Client queries for a matching repo to get the repo ID
// Client creates a sandbox based on the repo ID and any previous sandbox it may have
// In the event that the base sandbox (as indicated in in `based_on_sandbox`) does not exist, the client will receive an error and need to create a suitable sandbox.
//

service Build {
    // Clients need to obtain identifier for a repositories so that they can work with them.
    rpc QueryRepos (QueryReposAction.Request) returns (QueryReposAction.Response);

    rpc CreateSandbox (CreateSandbox.Request) returns (CreateSandbox.Response);

    rpc QueryTargets (QueryTargetsAction.Request) returns (QueryTargetsAction.Response);

    rpc IsolateWorkspace (IsolateWorkspaceAction.Request) returns (IsolateWorkspaceAction.Response);
}
